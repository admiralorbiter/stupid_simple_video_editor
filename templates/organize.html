{% extends "base.html" %}

{% block content %}
<div class="container-fluid mt-4">
    <div class="row">
        <div class="col-md-4">
            <div class="card">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <h5 class="mb-0">Folders</h5>
                    <div class="d-flex gap-2">
                        <div class="input-group">
                            <input type="text" 
                                   class="form-control form-control-sm" 
                                   id="folderSearch" 
                                   placeholder="Search folders..."
                                   oninput="filterFolders(this.value)">
                            <button class="btn btn-outline-secondary btn-sm" type="button" onclick="clearFolderSearch()">
                                <i class="bi bi-x"></i>
                            </button>
                        </div>
                        <button class="btn btn-primary btn-sm" onclick="createFolder()">
                            <i class="bi bi-plus-lg"></i>
                        </button>
                    </div>
                </div>
                <div class="card-body">
                    <div id="folder-tree">
                        {% for folder in folders %}
                            <div class="folder-item {% if folder.is_open %}open{% endif %}" 
                                 style="margin-left: {{ folder.level * 20 }}px"
                                 data-folder-id="{{ folder.id }}"
                                 data-position="{{ folder.position }}"
                                 draggable="true"
                                 ondragstart="onFolderDragStart(event)"
                                 ondragend="onFolderDragEnd(event)"
                                 ondragover="onFolderDragOver(event)"
                                 ondrop="onFolderDrop(event)">
                                <div class="d-flex align-items-center" onclick="toggleFolder(event, {{ folder.id }})">
                                    {% if folder.has_children %}
                                        <i class="bi bi-caret-right-fill me-1 folder-toggle"></i>
                                    {% else %}
                                        <i class="bi bi-dash me-1 text-muted"></i>
                                    {% endif %}
                                    <i class="bi bi-folder{% if folder.is_open %}-open{% endif %} me-2 text-warning"></i>
                                    <span class="folder-name">{{ folder.name }}</span>
                                    <div class="folder-actions ms-auto">
                                        <i class="bi bi-three-dots-vertical" onclick="showFolderMenu(event, {{ folder.id }})"></i>
                                    </div>
                                </div>
                                <div class="folder-videos" style="display: {% if folder.is_open %}block{% else %}none{% endif %}">
                                    {% for video in videos %}
                                        {% if video.folders and folder.name in video.folders.split(',') %}
                                            <div class="video-item ms-4 mt-2" data-video-id="{{ video.id }}">
                                                <div class="d-flex align-items-center">
                                                    <i class="bi bi-play-circle me-2"></i>
                                                    <span>{{ video.title }}</span>
                                                </div>
                                            </div>
                                        {% endif %}
                                    {% endfor %}
                                </div>
                            </div>
                        {% endfor %}
                    </div>
                </div>
            </div>
        </div>

        <div class="col-md-4">
            <div class="card">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <h5 class="mb-0">Tags</h5>
                    <div class="d-flex gap-2">
                        <div class="input-group">
                            <input type="text" 
                                   class="form-control form-control-sm" 
                                   id="tagSearch" 
                                   placeholder="Search tags..."
                                   oninput="filterTags(this.value)">
                            <button class="btn btn-outline-secondary btn-sm" type="button" onclick="clearTagSearch()">
                                <i class="bi bi-x"></i>
                            </button>
                        </div>
                        <div class="dropdown">
                            <button class="btn btn-primary btn-sm dropdown-toggle" type="button" data-bs-toggle="dropdown">
                                <i class="bi bi-plus-lg"></i>
                            </button>
                            <ul class="dropdown-menu dropdown-menu-end">
                                <li><a class="dropdown-item" href="#" onclick="createCategory()">New Category</a></li>
                                <li><a class="dropdown-item" href="#" onclick="createTag()">New Tag</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
                <div class="card-body">
                    <!-- Uncategorized tags -->
                    <div class="mb-4">
                        <h6 class="mb-2">Uncategorized</h6>
                        <div class="tag-group">
                            {% if tags %}
                                {% for tag in tags %}
                                    <span class="tag-item badge"
                                          draggable="true"
                                          data-tag-id="{{ tag.id }}"
                                          data-tag-name="{{ tag.name }}"
                                          data-tag-color="{{ tag.color }}"
                                          style="background-color: {{ tag.color }}">
                                        {{ tag.name }}
                                    </span>
                                {% endfor %}
                            {% else %}
                                <em class="text-muted">No uncategorized tags</em>
                            {% endif %}
                        </div>
                    </div>

                    <!-- Categories -->
                    {% for category in categories %}
                        <div class="tag-category mb-3"
                             data-category-id="{{ category.id }}"
                             ondragover="onDragOver(event)"
                             ondragleave="onDragLeave(event)"
                             ondrop="onCategoryDrop(event)">
                            <h6 class="mb-2">{{ category.name }}</h6>
                            <div class="tag-group">
                                {% if category.tags %}
                                    {% for tag in category.tags %}
                                        <span class="tag-item badge"
                                              draggable="true"
                                              data-tag-id="{{ tag.id }}"
                                              data-tag-name="{{ tag.name }}"
                                              data-tag-color="{{ tag.color }}"
                                              style="background-color: {{ tag.color }}">
                                            {{ tag.name }}
                                        </span>
                                    {% endfor %}
                                {% else %}
                                    <em class="text-muted">No tags</em>
                                {% endif %}
                            </div>
                        </div>
                    {% endfor %}
                </div>
            </div>
        </div>

        <div class="col-md-4">
            <div class="card">
                <div class="card-header">
                    <div class="d-flex justify-content-between align-items-center">
                        <h5 class="mb-0">Videos</h5>
                        <div>
                            <button class="btn btn-outline-primary" onclick="moveSelectedVideos()">
                                Move to Folder
                            </button>
                        </div>
                    </div>
                </div>
                <div class="card-body">
                    <div id="video-grid" class="row g-3">
                        {% for video in videos %}
                            <div class="col-12 video-item" 
                                 data-video-id="{{ video.id }}"
                                 ondragover="onDragOver(event)"
                                 ondragleave="onDragLeave(event)"
                                 ondrop="onVideoDrop(event)">
                                <div class="d-flex align-items-center">
                                    <input type="checkbox" class="form-check-input me-3">
                                    <div class="video-info">
                                        <h6 class="mb-1">{{ video.title }}</h6>
                                        {% if video.folders %}
                                            <small class="text-muted">
                                                <i class="bi bi-folder me-1"></i>{{ video.folders }}
                                            </small>
                                        {% endif %}
                                        <div class="video-tags mt-1">
                                            {% if video.tags %}
                                                {% for tag in video.tags.split(',') if tag %}
                                                    <span class="badge me-1" style="background-color: {{ tag_colors.get(tag, '#6c757d') }}">
                                                        {{ tag }}
                                                    </span>
                                                {% endfor %}
                                            {% endif %}
                                        </div>
                                    </div>
                                </div>
                            </div>
                        {% endfor %}
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Add this modal HTML at the bottom of your content block -->
<div class="modal fade" id="folderSelectModal" tabindex="-1">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Select Folder</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <div class="folder-select-list">
                    {% for folder in folders %}
                        <div class="folder-select-item" 
                             style="padding-left: {{ folder.level * 20 }}px"
                             data-folder-id="{{ folder.id }}">
                            <i class="bi bi-folder me-2 text-warning"></i>
                            {{ folder.name }}
                        </div>
                    {% endfor %}
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-primary" onclick="confirmFolderSelection()">Move</button>
            </div>
        </div>
    </div>
</div>

<!-- Add these styles -->
<style>
.folder-item {
    padding: 0.5rem;
    cursor: pointer;
    border-radius: 4px;
    transition: all 0.2s ease;
}

.folder-item:hover {
    background-color: var(--bs-light);
}

.folder-item.active {
    background-color: var(--bs-primary-bg-subtle);
}

.folder-item .folder-actions {
    opacity: 0;
    transition: opacity 0.2s ease;
}

.folder-item:hover .folder-actions {
    opacity: 1;
}

.folder-toggle {
    transition: transform 0.2s ease;
    cursor: pointer;
}

.folder-item.open > div > .folder-toggle {
    transform: rotate(90deg);
}

.folder-name {
    user-select: none;
}

/* Folder drag and drop styles */
.folder-item.drag-over {
    background-color: var(--bs-primary-bg-subtle);
    transform: translateX(5px);
}

.tag-item {
    cursor: grab;
    display: inline-block;
    margin: 2px;
    user-select: none;
}

.tag-item.dragging {
    opacity: 0.5;
}

.video-item {
    padding: 1rem;
    border-bottom: 1px solid var(--bs-border-color);
    transition: all 0.2s ease;
}

.video-item:last-child {
    border-bottom: none;
}

.video-item.drag-over {
    background-color: var(--bs-light);
    transform: translateX(5px);
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.video-tags {
    margin-top: 0.5rem;
}

.video-tags .badge {
    margin-right: 0.25rem;
}

.badge {
    cursor: pointer;
    transition: all 0.2s ease;
}

.badge:hover {
    transform: scale(1.05);
}

.folder-select-list {
    max-height: 300px;
    overflow-y: auto;
}

.folder-select-item {
    padding: 8px;
    cursor: pointer;
    border-radius: 4px;
    transition: background-color 0.2s;
}

.folder-select-item:hover {
    background-color: var(--bs-light);
}

.folder-select-item.selected {
    background-color: var(--bs-primary-bg-subtle);
}

/* Add these styles */
.folder-item .folder-item {
    display: none;
}

.folder-item.open > .folder-item {
    display: block;
}

.folder-videos {
    transition: all 0.3s ease;
}

.folder-item .video-item {
    font-size: 0.9em;
    padding: 0.3rem;
    border-radius: 4px;
}

.folder-item .video-item:hover {
    background-color: var(--bs-light);
}

.input-group {
    width: auto;
}

.input-group .form-control {
    width: 150px;
    transition: width 0.3s ease;
}

.input-group .form-control:focus {
    width: 200px;
}

/* Update existing folder styles */
.folder-item {
    transition: all 0.3s ease;
}

.highlight {
    background-color: rgba(255, 255, 255, 0.2);
    border-radius: 2px;
    padding: 0 2px;
}

.tag-item {
    transition: all 0.3s ease;
}

#tag-list {
    min-height: 50px; /* Prevents layout shift when filtering */
}

/* Update existing tag styles */
.tag-item .badge {
    transition: all 0.3s ease;
    white-space: normal;
    text-align: left;
}

.tag-category {
    border-bottom: 1px solid var(--bs-border-color);
    padding-bottom: 1rem;
}

.tag-category:last-child {
    border-bottom: none;
}

.category-name {
    font-size: 0.9rem;
    font-weight: 600;
    margin-bottom: 0.5rem;
}

.tag-group {
    display: flex;
    flex-wrap: wrap;
    gap: 0.25rem;
}

.tag-item:active {
    cursor: grabbing;
}

.folder-item.drag-over {
    background-color: var(--bs-primary-bg-subtle);
}

.drag-over {
    background-color: rgba(0, 123, 255, 0.1);
    border-radius: 4px;
    padding: 8px;
}

.tag-category {
    padding: 8px;
    border-radius: 4px;
    border: 1px solid transparent;
}

.tag-category.drag-over {
    border-color: var(--bs-primary);
}

.folder-item.dragging {
    opacity: 0.5;
    cursor: move;
}

.folder-item.drag-over {
    border: 2px dashed var(--bs-primary);
}

.folder-item.drag-above {
    border-top: 2px solid var(--bs-primary);
}

.folder-item.drag-below {
    border-bottom: 2px solid var(--bs-primary);
}

.folder-item.drag-above {
    border-top: 2px solid var(--bs-primary);
    padding-top: calc(0.5rem - 2px);
    margin-top: 2px;
}

.folder-item.drag-below {
    border-bottom: 2px solid var(--bs-primary);
    padding-bottom: calc(0.5rem - 2px);
    margin-bottom: 2px;
}

.folder-item.drag-over {
    background-color: var(--bs-primary-bg-subtle);
    border: 2px dashed var(--bs-primary);
}

.folder-item {
    position: relative;
}

/* Add drop zone indicators */
.folder-item::before,
.folder-item::after {
    content: '';
    position: absolute;
    left: 0;
    right: 0;
    height: 8px;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.2s;
}

.folder-item::before {
    top: -4px;
}

.folder-item::after {
    bottom: -4px;
}

.folder-item.drag-above::before,
.folder-item.drag-below::after {
    opacity: 1;
    background-color: var(--bs-primary);
}
</style>

{% block extra_js %}
<script>
// Declare folderSelectModal only once at the top
let folderSelectModal;

document.addEventListener('DOMContentLoaded', function() {
    folderSelectModal = new bootstrap.Modal(document.getElementById('folderSelectModal'));

    // Initialize drag and drop handlers
    document.querySelectorAll('.tag-item').forEach(tag => {
        tag.addEventListener('dragstart', function(e) {
            console.log('DragStart triggered for tag:', this.dataset);
            e.dataTransfer.setData('application/json', JSON.stringify({
                id: this.dataset.tagId,
                name: this.dataset.tagName,
                color: this.dataset.tagColor
            }));
            this.classList.add('dragging');
        });

        tag.addEventListener('dragend', function(e) {
            console.log('DragEnd triggered');
            this.classList.remove('dragging');
        });
    });

    // Add event listeners to drop targets (categories and videos)
    document.querySelectorAll('.tag-category, .video-item').forEach(dropTarget => {
        dropTarget.addEventListener('dragover', function(e) {
            e.preventDefault();
            this.classList.add('drag-over');
        });

        dropTarget.addEventListener('dragleave', function(e) {
            this.classList.remove('drag-over');
        });
    });

    // Add drop handlers for categories
    document.querySelectorAll('.tag-category').forEach(category => {
        category.addEventListener('drop', async function(e) {
            e.preventDefault();
            this.classList.remove('drag-over');
            
            try {
                const tagData = JSON.parse(e.dataTransfer.getData('application/json'));
                console.log('Category drop - Tag data:', tagData);
                
                const response = await fetch(`/api/tags/${tagData.id}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        category_id: this.dataset.categoryId || null
                    })
                });

                if (!response.ok) throw new Error('Failed to update tag');
                location.reload();
            } catch (error) {
                console.error('Error in category drop:', error);
                alert('Failed to move tag. Please try again.');
            }
        });
    });

    // Add drop handlers for videos
    document.querySelectorAll('.video-item').forEach(video => {
        video.addEventListener('drop', async function(e) {
            e.preventDefault();
            this.classList.remove('drag-over');
            
            try {
                const tagData = JSON.parse(e.dataTransfer.getData('application/json'));
                console.log('Video drop - Tag data:', tagData);
                
                const response = await fetch('/api/videos/organize', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        video_ids: [this.dataset.videoId],
                        tag_ids: [tagData.id]
                    })
                });

                if (!response.ok) throw new Error('Failed to add tag to video');
                
                // Add visual feedback
                const tagsContainer = this.querySelector('.video-tags');
                const newTag = document.createElement('span');
                newTag.className = 'badge me-1';
                newTag.style.backgroundColor = tagData.color;
                newTag.textContent = tagData.name;
                tagsContainer.appendChild(newTag);
            } catch (error) {
                console.error('Error in video drop:', error);
                alert('Failed to add tag to video. Please try again.');
            }
        });
    });
});

async function createFolder() {
    const name = await showPrompt('Enter folder name:');
    if (!name) return;
    
    try {
        const response = await fetch('/api/folders', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ name })
        });
        
        const data = await response.json();
        if (data.status === 'success') {
            location.reload(); // Refresh to show new folder
        }
    } catch (error) {
        console.error('Error creating folder:', error);
    }
}

async function createTag() {
    const name = await showPrompt('Enter tag name:');
    if (!name) return;
    
    const color = '#' + Math.floor(Math.random()*16777215).toString(16); // Random color
    
    try {
        const response = await fetch('/api/tags', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ name, color })
        });
        
        const data = await response.json();
        if (data.status === 'success') {
            location.reload(); // Refresh to show new tag
        }
    } catch (error) {
        console.error('Error creating tag:', error);
    }
}

let selectedFolderId = null;

function moveSelectedVideos() {
    const selectedVideos = getSelectedVideoIds();
    if (selectedVideos.length === 0) {
        alert('Please select videos to move');
        return;
    }
    
    // Reset selection
    selectedFolderId = null;
    document.querySelectorAll('.folder-select-item').forEach(i => 
        i.classList.remove('selected'));
    
    // Show modal
    folderSelectModal.show();
}

async function confirmFolderSelection() {
    if (!selectedFolderId) {
        alert('Please select a folder');
        return;
    }
    
    const selectedVideos = getSelectedVideoIds();
    
    try {
        const response = await fetch('/api/videos/organize', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                video_ids: selectedVideos,
                folder_ids: [selectedFolderId]
            })
        });
        
        const data = await response.json();
        if (data.status === 'success') {
            folderSelectModal.hide();
            location.reload();
        }
    } catch (error) {
        console.error('Error moving videos:', error);
    }
}

function getSelectedVideoIds() {
    const checkboxes = document.querySelectorAll('#video-grid input[type="checkbox"]:checked');
    return Array.from(checkboxes).map(cb => cb.closest('.video-item').dataset.videoId);
}

async function showPrompt(message) {
    return prompt(message);
}

async function showPromptWithElement(message, element) {
    // You might want to replace this with a modal dialog
    return prompt(message);
}

// Utility function to log drag and drop events
function logEvent(name, event) {
    console.log(`${name}:`, {
        target: event.target,
        currentTarget: event.currentTarget,
        dataTransfer: event.dataTransfer?.types
    });
}

// Debug logging function
function debug(event, message, data = null) {
    console.log(`[${event}]`, message, data);
}

function onTagDragStart(event) {
    debug('DragStart', 'Event triggered');
    
    const tagItem = event.target.closest('.tag-item');
    if (!tagItem) {
        debug('DragStart', 'No tag-item found');
        return;
    }
    
    const tagData = {
        id: tagItem.getAttribute('data-tag-id'),
        name: tagItem.getAttribute('data-tag-name'),
        color: tagItem.getAttribute('data-tag-color')
    };
    
    debug('DragStart', 'Tag data:', tagData);
    
    // Store the data as a JSON string
    event.dataTransfer.setData('application/json', JSON.stringify(tagData));
}

function onDragOver(event) {
    event.preventDefault();
    debug('DragOver', 'Event triggered');
    event.dataTransfer.dropEffect = 'move';
    event.currentTarget.classList.add('drag-over');
}

function onDragLeave(event) {
    event.preventDefault();
    debug('DragLeave', 'Event triggered');
    event.currentTarget.classList.remove('drag-over');
}

function onTagDragEnd(event) {
    debug('DragEnd', 'Event triggered');
    const tagItem = event.target;
    if (tagItem.classList.contains('tag-item')) {
        tagItem.classList.remove('dragging');
    }
}

async function onCategoryDrop(event) {
    event.preventDefault();
    debug('CategoryDrop', 'Event triggered');
    
    const category = event.currentTarget;
    category.classList.remove('drag-over');
    
    try {
        const tagDataStr = event.dataTransfer.getData('application/json');
        debug('CategoryDrop', 'Retrieved tag data:', tagDataStr);
        
        if (!tagDataStr) {
            debug('CategoryDrop', 'No tag data found');
            return;
        }
        
        const tagData = JSON.parse(tagDataStr);
        const categoryId = category.dataset.categoryId;
        
        debug('CategoryDrop', 'Processing drop', { 
            tagData, 
            categoryId,
            category: category.outerHTML 
        });
        
        const response = await fetch(`/api/tags/${tagData.id}`, {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                category_id: categoryId === '' ? null : parseInt(categoryId)
            })
        });
        
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const data = await response.json();
        debug('CategoryDrop', 'Response:', data);
        
        if (data.status === 'success') {
            // Add visual feedback before reload
            const sourceCategory = document.querySelector(`.tag-item[data-tag-id="${tagData.id}"]`).parentElement;
            const targetCategory = category.querySelector('.tag-group');
            const tagElement = document.querySelector(`.tag-item[data-tag-id="${tagData.id}"]`);
            
            if (tagElement && targetCategory) {
                targetCategory.appendChild(tagElement);
                if (sourceCategory && sourceCategory.children.length === 0) {
                    sourceCategory.innerHTML = '<em class="text-muted">No tags</em>';
                }
            }
            
            // Reload after a short delay to ensure the user sees the change
            setTimeout(() => location.reload(), 500);
        } else {
            throw new Error(data.message || 'Failed to move tag');
        }
    } catch (error) {
        console.error('Error moving tag:', error);
        alert('Failed to move tag. Please try again.');
    }
}

async function onVideoDrop(event) {
    event.preventDefault();
    debug('VideoDrop', 'Event triggered');
    
    const videoItem = event.currentTarget;
    videoItem.classList.remove('drag-over');
    
    try {
        const tagDataStr = event.dataTransfer.getData('application/json');
        debug('VideoDrop', 'Retrieved tag data:', tagDataStr);
        
        if (!tagDataStr) {
            debug('VideoDrop', 'No tag data found');
            return;
        }
        
        const tagData = JSON.parse(tagDataStr);
        const videoId = videoItem.dataset.videoId;
        
        debug('VideoDrop', 'Processing drop', { tagData, videoId });
        
        const response = await fetch('/api/videos/organize', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                video_ids: [videoId],
                tag_ids: [tagData.id]
            })
        });
        
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const data = await response.json();
        if (data.status === 'success') {
            // Add visual feedback
            const tagsContainer = videoItem.querySelector('.video-tags');
            const newTag = document.createElement('span');
            newTag.className = 'badge me-1';
            newTag.style.backgroundColor = tagData.color;
            newTag.textContent = tagData.name;
            tagsContainer.appendChild(newTag);
        } else {
            throw new Error(data.message || 'Failed to add tag to video');
        }
    } catch (error) {
        console.error('Error adding tag to video:', error);
        alert('Failed to add tag to video. Please try again.');
    }
}

function toggleFolder(event, folderId) {
    event.preventDefault();
    event.stopPropagation();
    
    const folderItem = event.currentTarget.closest('.folder-item');
    const caretIcon = folderItem.querySelector('.folder-toggle');
    const folderIcon = folderItem.querySelector('.bi-folder, .bi-folder-open');
    const folderVideos = folderItem.querySelector('.folder-videos');
    
    // Toggle folder state
    folderItem.classList.toggle('open');
    
    // Toggle folder icon
    if (folderIcon) {
        folderIcon.classList.toggle('bi-folder');
        folderIcon.classList.toggle('bi-folder-open');
    }
    
    // Toggle videos visibility
    if (folderVideos) {
        folderVideos.style.display = folderItem.classList.contains('open') ? 'block' : 'none';
    }
    
    // Update folder state in database
    fetch('/api/folders/' + folderId + '/toggle', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        }
    })
    .then(response => response.json())
    .then(data => {
        if (data.status !== 'success') {
            console.error('Failed to toggle folder:', data.message);
            // Revert all UI changes if the server update failed
            folderItem.classList.toggle('open');
            if (folderIcon) {
                folderIcon.classList.toggle('bi-folder');
                folderIcon.classList.toggle('bi-folder-open');
            }
            if (folderVideos) {
                folderVideos.style.display = folderItem.classList.contains('open') ? 'block' : 'none';
            }
        }
    })
    .catch(error => {
        console.error('Error toggling folder:', error);
        // Revert all UI changes on error
        folderItem.classList.toggle('open');
        if (folderIcon) {
            folderIcon.classList.toggle('bi-folder');
            folderIcon.classList.toggle('bi-folder-open');
        }
        if (folderVideos) {
            folderVideos.style.display = folderItem.classList.contains('open') ? 'block' : 'none';
        }
    });

    // Store the open state for search filtering
    if (folderItem.classList.contains('open')) {
        folderItem.setAttribute('data-was-open', 'true');
    } else {
        folderItem.removeAttribute('data-was-open');
    }
}

function showFolderMenu(event, folderId) {
    event.stopPropagation();
    // Show a context menu with folder actions
    const menu = document.createElement('div');
    menu.className = 'dropdown-menu show';
    menu.style.position = 'fixed';
    menu.style.left = event.pageX + 'px';
    menu.style.top = event.pageY + 'px';
    
    menu.innerHTML = `
        <a class="dropdown-item" href="#" onclick="renameFolder(${folderId})">
            <i class="bi bi-pencil me-2"></i>Rename
        </a>
        <a class="dropdown-item" href="#" onclick="createSubfolder(${folderId})">
            <i class="bi bi-folder-plus me-2"></i>New Subfolder
        </a>
        <div class="dropdown-divider"></div>
        <a class="dropdown-item text-danger" href="#" onclick="deleteFolder(${folderId})">
            <i class="bi bi-trash me-2"></i>Delete
        </a>
    `;
    
    document.body.appendChild(menu);
    
    // Close menu when clicking outside
    function closeMenu(e) {
        if (!menu.contains(e.target)) {
            menu.remove();
            document.removeEventListener('click', closeMenu);
        }
    }
    
    setTimeout(() => document.addEventListener('click', closeMenu), 0);
}

async function renameFolder(folderId) {
    const name = await showPrompt('Enter new folder name:');
    if (!name) return;
    
    try {
        const response = await fetch('/api/folders/' + folderId, {
            method: 'PATCH',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ name })
        });
        
        if (!response.ok) throw new Error('Failed to rename folder');
        
        const data = await response.json();
        if (data.status === 'success') {
            location.reload();
        } else {
            throw new Error(data.message || 'Failed to rename folder');
        }
    } catch (error) {
        console.error('Error renaming folder:', error);
        alert('Failed to rename folder. Please try again.');
    }
}

async function createSubfolder(parentId) {
    const name = await showPrompt('Enter subfolder name:');
    if (!name) return;
    
    try {
        const response = await fetch('/api/folders', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ name, parent_id: parentId })
        });
        
        if (response.ok) {
            location.reload();
        }
    } catch (error) {
        console.error('Error creating subfolder:', error);
    }
}

function onFolderDragStart(event) {
    draggedFolder = event.target.closest('.folder-item');
    draggedFolder.classList.add('dragging');
    event.dataTransfer.setData('text/plain', draggedFolder.dataset.folderId);
}

function onFolderDragEnd(event) {
    draggedFolder.classList.remove('dragging');
    draggedFolder = null;
    document.querySelectorAll('.folder-item').forEach(folder => {
        folder.classList.remove('drag-over');
    });
}

function onFolderDragOver(event) {
    event.preventDefault();
    const folderItem = event.target.closest('.folder-item');
    if (!folderItem || folderItem === draggedFolder) return;
    
    const rect = folderItem.getBoundingClientRect();
    const relativeY = event.clientY - rect.top;
    const percentage = relativeY / rect.height;
    
    folderItem.classList.remove('drag-over', 'drag-above', 'drag-below');
    
    if (percentage < 0.3) {
        folderItem.classList.add('drag-above');
    } else if (percentage > 0.7) {
        folderItem.classList.add('drag-below');
    } else {
        folderItem.classList.add('drag-over');
    }
}

async function onFolderDrop(event) {
    event.preventDefault();
    const folderItem = event.target.closest('.folder-item');
    if (!folderItem || folderItem === draggedFolder) return;
    
    folderItem.classList.remove('drag-over', 'drag-above', 'drag-below');
    
    const droppedFolderId = parseInt(event.dataTransfer.getData('text/plain'));
    const targetFolderId = parseInt(folderItem.dataset.folderId);
    const draggedElement = document.querySelector(`[data-folder-id="${droppedFolderId}"]`);
    
    // Get parent container and all its direct folder children
    const parentContainer = folderItem.parentElement;
    const parentFolder = parentContainer.closest('.folder-item');
    const parentId = parentFolder ? parseInt(parentFolder.dataset.folderId) : null;
    
    // Determine drop position
    const rect = folderItem.getBoundingClientRect();
    const dropPosition = event.clientY < (rect.top + rect.height * 0.3) ? 'before' :
                        event.clientY > (rect.top + rect.height * 0.7) ? 'after' : 
                        'inside';

    // Handle the drop based on position
    switch (dropPosition) {
        case 'before':
            parentContainer.insertBefore(draggedElement, folderItem);
            break;
        case 'after':
            parentContainer.insertBefore(draggedElement, folderItem.nextSibling);
            break;
        case 'inside':
            // Optional: Add logic for nesting folders
            break;
    }
    
    // Get all folders in their new order
    const updatedFolders = Array.from(
        parentContainer.querySelectorAll(':scope > .folder-item')
    );
    
    // Create positions array with explicit positions starting from 0
    const positions = updatedFolders.map((folder, index) => ({
        id: parseInt(folder.dataset.folderId),
        position: index,
        parent_id: parentId
    }));
    
    try {
        const response = await fetch('/api/folders/reorder', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ positions })
        });
        
        if (!response.ok) throw new Error('Failed to update folder positions');
        
        // Update visual feedback
        updatedFolders.forEach((folder, index) => {
            folder.dataset.position = index;
        });
    } catch (error) {
        console.error('Error reordering folders:', error);
        alert('Failed to reorder folders. Please try again.');
        location.reload(); // Reload to restore original order
    }
}

function filterFolders(searchTerm) {
    const folderItems = document.querySelectorAll('.folder-item');
    const normalizedSearch = searchTerm.toLowerCase().trim();
    
    folderItems.forEach(folder => {
        const folderName = folder.querySelector('.folder-name').textContent.toLowerCase();
        const matches = folderName.includes(normalizedSearch);
        
        if (matches) {
            folder.style.display = '';
            // Show parent folders of matching items
            let parent = folder.parentElement.closest('.folder-item');
            while (parent) {
                parent.style.display = '';
                parent.classList.add('open');
                parent = parent.parentElement.closest('.folder-item');
            }
        } else {
            // Only hide if none of the children match
            const hasMatchingChild = Array.from(folder.querySelectorAll('.folder-item')).some(child => 
                child.style.display !== 'none');
            folder.style.display = hasMatchingChild ? '' : 'none';
        }
    });
}

function clearFolderSearch() {
    const searchInput = document.getElementById('folderSearch');
    searchInput.value = '';
    filterFolders('');
    
    // Reset folder states
    document.querySelectorAll('.folder-item').forEach(folder => {
        folder.style.display = '';
        if (!folder.hasAttribute('data-was-open')) {
            folder.classList.remove('open');
        }
    });
}

function filterTags(searchTerm) {
    const tagItems = document.querySelectorAll('.tag-item');
    const normalizedSearch = searchTerm.toLowerCase().trim();
    
    tagItems.forEach(tag => {
        const tagName = tag.dataset.tagName.toLowerCase();
        const matches = tagName.includes(normalizedSearch);
        tag.style.display = matches ? '' : 'none';
        
        // Add highlight effect for matching tags
        const badge = tag.querySelector('.badge');
        if (matches && normalizedSearch) {
            const html = tagName.replace(
                new RegExp(normalizedSearch, 'gi'),
                match => `<span class="highlight">${match}</span>`
            );
            badge.innerHTML = html + ` (${tag.querySelector('.badge').textContent.split('(')[1]}`;
        } else {
            badge.innerHTML = tag.dataset.tagName + ` (${tag.querySelector('.badge').textContent.split('(')[1]}`;
        }
    });
}

function clearTagSearch() {
    const searchInput = document.getElementById('tagSearch');
    searchInput.value = '';
    filterTags('');
}

function createCategory() {
    const categoryName = prompt('Enter category name:');
    if (!categoryName) return;

    fetch('/api/categories', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({ name: categoryName })
    })
    .then(response => response.json())
    .then(data => {
        if (data.status === 'success') {
            window.location.reload();  // Refresh to show new category
        } else {
            alert('Error creating category: ' + data.message);
        }
    })
    .catch(error => console.error('Error:', error));
}

function showCategoryMenu(event, categoryId) {
    event.stopPropagation();
    
    // Create and show a Bootstrap dropdown menu
    const menu = document.createElement('div');
    menu.className = 'dropdown-menu show';
    menu.style.position = 'fixed';
    menu.style.left = event.pageX + 'px';
    menu.style.top = event.pageY + 'px';
    
    menu.innerHTML = `
        <a class="dropdown-item" href="#" onclick="renameCategory(${categoryId})">Rename</a>
        <a class="dropdown-item text-danger" href="#" onclick="deleteCategory(${categoryId})">Delete</a>
    `;
    
    document.body.appendChild(menu);
    
    // Close menu when clicking outside
    const closeMenu = (e) => {
        if (!menu.contains(e.target)) {
            menu.remove();
            document.removeEventListener('click', closeMenu);
        }
    };
    setTimeout(() => document.addEventListener('click', closeMenu), 0);
}

function onTagDragStart(event) {
    event.dataTransfer.setData('text/plain', event.target.dataset.tagId);
}

async function deleteFolder(folderId) {
    if (!confirm('Are you sure you want to delete this folder and all its subfolders? This cannot be undone.')) {
        return;
    }
    
    try {
        const response = await fetch('/api/folders/' + folderId, {
            method: 'DELETE',
            headers: {
                'Content-Type': 'application/json',
            }
        });
        
        if (!response.ok) throw new Error('Failed to delete folder');
        
        const data = await response.json();
        if (data.status === 'success') {
            location.reload();
        } else {
            throw new Error(data.message || 'Failed to delete folder');
        }
    } catch (error) {
        console.error('Error deleting folder:', error);
        alert('Failed to delete folder. Please try again.');
    }
}

// Add other necessary functions (renameCategory, deleteCategory, etc.)
</script>
{% endblock %}
{% endblock %} 